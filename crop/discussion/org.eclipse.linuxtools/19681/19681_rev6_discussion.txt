DESCRIPTION

tmf: add a doQuery version with an intervals listener (draft).

The doQuery method populates a List (ArrayList) with intervals
intersecting a given timestamp.

Most of the time, the produced array is used to iterate and
its creation wasn't necessary. This is a producer/consumer design
which could be better abstracted by a listener linking the publisher of
an intervals to the consumer.

This patch-set provides the idea without fully replacing the actual
doQuery implementation. The listener concept is actually unused.

Change-Id: I78d77a8683a50e699044d629d943ad801496dc84
Signed-off-by: Jordon Obrien xxx@xxx.xxx


COMMENTS

author: Jordon Obrien
date: 2013-12-12 07:15:17.000000000

Uploaded patch set 6.

-------------------------------------
author: Brenden Conley
date: 2013-12-12 08:13:07.000000000

Patch Set 6:

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/4606/

-------------------------------------
author: Brenden Conley
date: 2013-12-12 08:48:14.000000000

Patch Set 6: Verified+1

Build Successful 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/4606/ : SUCCESS

-------------------------------------
author: Braxton Mccarthy
date: 2013-12-12 15:47:59.000000000

Patch Set 6:

This looks like an interesting approach!

The idea of returning the results in an arraylist was so that the view could then access each "attribute" in O(1) (since the attribute quark is the index in the array).

But it's true that many views today don't really need quarks in particular, they look at the whole thing (or a relatively large subset of it). In that case they could handle the data as they receive it, in any order.

If a view/analysis really wants to get the information "the old way", they can build the arraylist themselves and wait until all the data is available.

Will look more deeply at it next.

-------------------------------------
author: Jordon Obrien
date: 2013-12-12 15:53:47.000000000

Patch Set 6:

The idea to returns a "ArrayList" scale when you have a few attributes and they are in sequence. Otherwise, it's not sparse.

The O(1) access is nice (should be keep in mind for some "cases").

But, the danger with the interface is that a "List" is exposed and somebody could provide a "LinkedList" and the algorithm will run O(n2):
  forach intervals           <-- n times
    list.set(quark, value)   <-- n times (set in linked list)

You should add people working on "views" to provide feedback. This is a "fundamental" changes of way you can think a query.

-------------------------------------
