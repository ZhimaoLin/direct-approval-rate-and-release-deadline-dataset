DESCRIPTION

lttng: Add unit tests for the CPU usage analysis

The unit tests make use of the XML development trace.

Also correct the fact that a process that hasn't run yet started at -1 instead
of 0. There probably was a reason in the original implementation, but 0 works
fine now.

Change-Id: Ifc74c5ebcc08bc714e2baf42346295b1b571c6ff
Signed-off-by: Aryana Jones xxx@xxx.xxx


COMMENTS

author: Annalise Jimenez
date: 2014-08-14 21:17:35.000000000

Uploaded patch set 11.

-------------------------------------
author: Brenden Conley
date: 2014-08-15 04:56:24.000000000

Patch Set 11:

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/8309/

-------------------------------------
author: Brenden Conley
date: 2014-08-15 05:37:29.000000000

Patch Set 11: Verified-1

Build Failed 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/8309/ : FAILURE

-------------------------------------
author: Brenden Conley
date: 2014-08-21 21:17:43.000000000

Patch Set 11: -Verified

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/8483/

-------------------------------------
author: Brenden Conley
date: 2014-08-21 21:58:01.000000000

Patch Set 11: Verified+1

Build Successful 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/8483/ : SUCCESS

-------------------------------------
author: Braxton Mccarthy
date: 2014-09-19 22:42:17.000000000

Patch Set 11: Code-Review-1

(5 comments)

some comments

Line:140, lttng/org.eclipse.linuxtools.lttng2.kernel.core.tests/src/org/eclipse/linuxtools/lttng2/kernel/core/tests/cpuusage/CpuUsageStateProviderTest.java -> If the iteration order is constant here (and it should be?), you could use an Iterator :O and do something like:

  assertTrue("CPUs/0/1", iterator.next());
  assertTrue("CPUs/0/2", iterator.next());
  etc.

This way you test not only that the values are present, but in the order they are expected.

Or, sometimes just one assertEquals(expectedCollection, actualCollection) could work and would do the same thing.

I mean, it seems weird to do a swtich/case inside a for loop and expect to hit every single enumerated value once. You could just go through them one by one.

Line:183, lttng/org.eclipse.linuxtools.lttng2.kernel.core.tests/src/org/eclipse/linuxtools/lttng2/kernel/core/tests/cpuusage/CpuUsageStateProviderTest.java -> Ok, I haven't seen the KernelCpuUsage stuff go in, or I would have noted that this is a VERY weird way of storing things ;)

How about instead of a String, having the key in the map be a new class that contains two ints (or longs): one for CPU one for TID. Its toString() could output it the same way. But this would be a little more robust, and would allow going through the list in order, as mentioned in the comment above.

Outside of the scope of this patch though.

Line:71, lttng/org.eclipse.linuxtools.lttng2.kernel.core/src/org/eclipse/linuxtools/lttng2/kernel/core/cpuusage/LttngKernelCpuUsageAnalysis.java -> This change is to support the case where there would be more than one LttngKernelAnalysisModule?

If so, then why only start the first one, you should while(iterator.hasNext()) and start every one of them?

If not, then why the change?

Line:130, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/tmf/core/statesystem/TmfStateSystemAnalysisModule.java -> will probably be 3.2

Line:132, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/tmf/core/statesystem/TmfStateSystemAnalysisModule.java -> Even though method name overloading works in Java, I'd slightly prefer to use a different name (like getStateSystemOfClass() here). Makes it harder to mistakenly forget/add one parameter.

-------------------------------------
author: Annalise Jimenez
date: 2014-09-22 20:13:10.000000000

Patch Set 11:

(3 comments)

some answers to comments

Line:140, lttng/org.eclipse.linuxtools.lttng2.kernel.core.tests/src/org/eclipse/linuxtools/lttng2/kernel/core/tests/cpuusage/CpuUsageStateProviderTest.java -> I don't know about the order. It depends on the state system implementation, so I cannot assume it will always be constant. In this implementation maybe but who can tell!

I could add an assertEquals of 2 collections to make sure that the attribute paths are all present, but I do want to make asserts on the state value of each interval (that's what unit tests are about after all!), so I don't have much choice but to add this switch/case.

Line:183, lttng/org.eclipse.linuxtools.lttng2.kernel.core.tests/src/org/eclipse/linuxtools/lttng2/kernel/core/tests/cpuusage/CpuUsageStateProviderTest.java -> Indeed, I could use something else as the key of the map, but it was MUCH simpler for a first implementation to use a string :D

Line:71, lttng/org.eclipse.linuxtools.lttng2.kernel.core/src/org/eclipse/linuxtools/lttng2/kernel/core/cpuusage/LttngKernelCpuUsageAnalysis.java -> Actually, it is to support the case where 2 analysis modules with different IDs, but using the same class, are used. 

For instance. LttngKernelAnalysisModule.ID is the analysis module that runs for LttngKernelTrace class. But the trace stub also has all necessary characteristics to be able to have the Lttng Kernel analysis module run on it, so a new analysis module with another ID was defined in the extension point. So what we want to get here is the module by class and not by id.

-------------------------------------
