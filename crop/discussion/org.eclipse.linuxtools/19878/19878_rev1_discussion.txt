DESCRIPTION

Tmf: Prototype of Ust memory usage chart

This patch is an example of the use of the new xy line charts implementation.
It is a rework of Matthew's draft patch here
https://git.eclipse.org/r/#/c/15935/2

Change-Id: I18566e0eb6cd87103571f17ce88006b6edc53fd5
Signed-off-by: Ivy Mitchell xxx@xxx.xxx
Signed-off-by: Aryana Jones xxx@xxx.xxx


COMMENTS

author: Brenden Conley
date: 2013-12-16 22:15:29.000000000

Patch Set 1:

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/4714/

-------------------------------------
author: Brenden Conley
date: 2013-12-16 22:47:57.000000000

Patch Set 1: Verified-1

Build Failed 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/4714/ : FAILURE

-------------------------------------
author: Ivy Mitchell
date: 2013-12-17 22:52:22.000000000

Patch Set 1: Code-Review-1

(3 comments)

Looks like a good start. 

Some comments: Luciana Barry redid the histogram to behave like the control flow view. Maybe this chart should behave similarly. 

I find it more readable than my original patch, thank you.

Will the patch include at a later date the kernel memory usage in the same chart?

Line:17, lttng/org.eclipse.linuxtools.tracing.examples/pom.xml -> we need a link to swtcharts here.

Line:104, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> I like these functions so much I feel they should be commented. Also, get vtid + getProcname are nice additions.

Line:131, lttng/org.eclipse.linuxtools.lttng2.ust.ui/src/org/eclipse/linuxtools/internal/lttng2/ust/ui/views/memusage/MemoryUsageViewer.java -> to be removed later

-------------------------------------
author: Ivy Mitchell
date: 2013-12-17 22:54:31.000000000

Patch Set 1:

Also, it would be a nice feature to have a dynamic Y axis that changes from KB to MB and GB if the scale is big enough.

-------------------------------------
author: Annalise Jimenez
date: 2013-12-18 01:40:55.000000000

Patch Set 1:

(3 comments)

I'll take a look at the histogram then and see how they can behave like the time graph views. 

But indeed, I hadn't thought of it this way, but it can be viewed as entries with values in time... It's just a different way to representing it and keeping those values (interval vs points)

As for lttng kernel included... I'd rather do that in an experiment type that will include simultaneous ust/kernel traces and build an analysis on this experiment. Maybe this is where this view will move to eventually.

Line:17, lttng/org.eclipse.linuxtools.tracing.examples/pom.xml -> What is that doing here anyway...

Line:104, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> Which functions are you talking about? And commented as in "Add some comments to it" or as in "/* I was here */"

Line:131, lttng/org.eclipse.linuxtools.lttng2.ust.ui/src/org/eclipse/linuxtools/internal/lttng2/ust/ui/views/memusage/MemoryUsageViewer.java -> Of course... slipped my keys ;-)

-------------------------------------
author: Jordon Obrien
date: 2013-12-18 15:16:31.000000000

Patch Set 1:

(11 comments)

drive-by
I didn't take a look on the behavior, next reading.

plenty of nits

Line:16, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/UstMemoryStrings.java -> ust -> UST

Line:24, lttng/org.eclipse.linuxtools.lttng2.ust.ui/src/org/eclipse/linuxtools/lttng2/ust/ui/analysis/memory/UstMemoryAnalysisModule.java -> ust -> UST

Do you build "on" a trace? or "from" a trace?

And, you do not build "from" the instrumentation, but from the events "produced" by the instrumentation.

We get your idea, but the sentence make no sense.

Line:24, lttng/org.eclipse.linuxtools.tracing.examples/pom.xml -> examples????

Line:1, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> General question...
It is the kind of stuff you would prefer in XML, bundle with the "plugin"?
I never tried the XML written by Florian. So, I don't know.

Line:11, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> total memory* is kept

Line:32, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> Ust make no sense.
UST   <<-- three letter abbrv.

Line:40, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> should use the same coding convention.
Pick one and stay to it:

eventNames -> fEventNames.

Line:46, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> Missing comment

Line:34, lttng/org.eclipse.linuxtools.lttng2.ust.ui/src/org/eclipse/linuxtools/internal/lttng2/ust/ui/views/memusage/MemoryUsageViewer.java -> This is a comment that need to dig in your head.
I'm a code reviewer and I do not know what you are talking about.
This should guide me through my reading.

What is a memory view?
What are the assumption, requirement, etc... ?

Line:114, lttng/org.eclipse.linuxtools.lttng2.ust.ui/src/org/eclipse/linuxtools/internal/lttng2/ust/ui/views/memusage/MemoryUsageViewer.java -> That's the kind of stuff I prefer to read:

Math.max(x,y)

It is faster for my brain to make the link between "max", but it take more time to figure out time < x ? x : y.

Readability first.

Line:18, lttng/org.eclipse.linuxtools.lttng2.ust.ui/src/org/eclipse/linuxtools/internal/lttng2/ust/ui/views/memusage/Messages.java -> ust -> UST

-------------------------------------
author: Jordon Obrien
date: 2013-12-18 15:30:04.000000000

Patch Set 1:

I you really want to play the game on "how to package".
This patch-set should be divide into two patch-set.

1) The state provide
2) The view

One is dependant on the other.

These two concepts are independant and are easier to code review when splitted. By providing both at the same time, you can guide the reader where you are going and also help him reading one aspect at the time.

Also, by splitting it, it is more easier to see the "public API" and think about what is exposed.

Also, by splitting it, it come obvious you provide no unittest. For me, this is bad!

TMF needs to fix this. :)

-------------------------------------
author: Jordon Obrien
date: 2013-12-18 15:43:06.000000000

Patch Set 1:

(2 comments)

more comments

Line:7, /COMMIT_MSG -> Ust -> UST

Line:9, /COMMIT_MSG -> The primary goal of this patch-set is to be an example?
I think it's a memory usage state-provide/view implementation.
It the plan is to be an example, it should be committed in an example folder (which is not the case).
The commit log should reflect this fact.

For sure, it is also the first use you did for the charts.
But, this is not the main goal of the code.
It may be your "personal" goal (learning, prototyping, etc...), but it is not the purpose of the "line of codes written".

Keep in mind, the commit log is used to
  - guide the code review
    - explain the purpose of the patch-set
    - give all the information needed to be understand (no contextual information)
  - have an history to navigate and understand design choice
    - performance choice
    - design choice

-------------------------------------
author: Ivy Mitchell
date: 2013-12-18 20:24:55.000000000

Patch Set 1:

Etienne, I am sorry, the "how to package" game thing is completely out of context If it is being put on a public forum, please bring the reviewers up to speed. I had to contact Genevieve to understand the context, and this is very disruptive to the workflow.

-------------------------------------
author: Ayanna Reed
date: 2013-12-24 14:12:53.000000000

Patch Set 1:

(2 comments)

Line:1, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> Currently not easy because of the hashmap. We first need to allow access to multiple backend. And a hashmap should be a possible backend (as a history tree)

Line:41, lttng/org.eclipse.linuxtools.lttng2.ust.core/src/org/eclipse/linuxtools/internal/lttng2/ust/core/stateprovider/MemoryUsageStateProvider.java -> I think the addresses are virtual. Is it possible to trace with multiple processes? In this case it should be a multimap (pid, ptr).

-------------------------------------
