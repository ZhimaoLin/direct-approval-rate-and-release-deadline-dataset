DESCRIPTION

tmf: Initial commit of Pcap Parser

Change-Id: I334571c06a44cec99f9e37011fbfaa27b6a414e3
Signed-off-by: Itzel Singleton xxx@xxx.xxx


COMMENTS

author: Itzel Singleton
date: 2014-06-03 22:11:29.000000000

Uploaded patch set 1.

-------------------------------------
author: Braxton Mccarthy
date: 2014-06-04 21:46:35.000000000

Patch Set 1: Code-Review-1

(34 comments)

Some comments so far, looked at up to PcapFile.

As mentioned in the comments, add the missing copyright headers, remove xxx@xxx.xxx tags. And no need for "public" in interfaces (and "static final" for interface fields).

Your interfaces with constants shouldn't be called SomethingField. "Field" would be more for an actual object that represent the field of the thing. Those should be more TcpValues, or TcpProtocolValues  etc.

There's also no synchronization in PcapFile. It can cause problems if differentt threads call for instance parseNextPacket() at the same time. We can review that separately.

Line:1, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/IPv4Field.java -> copyright header

Line:6, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/IPv4Field.java -> remove

Line:13, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/IPv4Field.java -> remove public static final

Line:24, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> those comments for instance are informative!

Line:28, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> if you hold resources to Closeable objects as class fields, it would be very good practice to make your class (Auto)Closeable itself (implements AutoCloseable). This also means implementing a close() method in here in which you .close() those objects.

Line:37, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> could be made final

Line:56, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> no need to mention NullPointerException, it's a RuntimeException (also called "uncheck exception") so can "always" happen even if methods don't put it in their signatuure.

For the others, what does BadPcapFileException and IllegalMagicNumber exception bring? Why not just throw an IOException? (genuinely asking, there might be good reasons)

Line:71, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> Interesting, I've never seen a FileChannel instantiated like that!

Although it'd be better to go through a FileInputStream, and then do fis.getChannel(). This guarantees the file channel is in read-only mode.

If you keep the reference to the FileInputStream you could also .close() it at the same time of the FileChannel.

Line:77, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> Call globalHeader.clear() before using it. I'm not 100% sure why, but that's what the docs suggest.

Line:79, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> nonono, you're supposed to do globalHeader.flip() here. With that I don't think you'll to do .position(0).

Line:89, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> fFileChannel.close(); here

Line:116, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> It's C-style to declare variables separately, but in Java (in this project at least), we usually just declare it wherever we need it. This can help with scoping the variables too.

Line:123, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> ByteBuffer.clear()

Line:128, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> .flip() instead. Not sure if you'll still have to .position() afterwards

Line:134, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> .clear()

Line:138, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> .flip() instead

Line:159, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> add a .clear()

Line:164, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> .flip()

Line:166, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> might not be needed...

Line:190, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> maybe you can use TreeMap.floor() or .ceiling() here

Line:269, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> What's the use of this method?

The other getters are ok, because they report immutable values about this object. But the boolean here can flip from true to false while other threads seek it. So if a user calls this, the return values can become immediately obsolete.

Line:1, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/EthernetIIField.java -> missing copyright header (just copy-paste the one from another file, with 2014 and your name)

Line:4, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/EthernetIIField.java -> What is Ethernet II? (I am not sure myself...) is it a protocol? This could be explained in this javadoc

Line:6, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/EthernetIIField.java -> no need xxx@xxx.xxx it's not very useful

Line:14, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/EthernetIIField.java -> remove "public static final" here, since it's in an interface it is already public-static-final by definition

Line:23, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/BadPcapFileException.java -> what stuff? not a very informative comment ;)

you can always add things later

Line:2, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/internal/pcap/core/Activator.java -> 2014

Line:10, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/internal/pcap/core/Activator.java -> Put your name instead, you created this file

Line:34, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/internal/pcap/core/Activator.java -> pcap.core

Line:15, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/ProtocolField.java -> perhaps this would be better as an enum?

Line:10, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/IllegalMagicNumberException.java -> looks ok, but is it really needed? Why not just throw a BadPcapFileException, what would this bring?

Line:1, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/PcapFileField.java -> copyright header

Line:6, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/PcapFileField.java -> remove

Line:15, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/PcapFileField.java -> remove public static final


those three comments apply to all similar files too

-------------------------------------
author: Braxton Mccarthy
date: 2014-06-04 23:15:54.000000000

Patch Set 1:

(48 comments)

Rest of the first pass of comments. That should keep you busy for a bit. ;)

Looks pretty good so far though! nice work.

Also, perhaps it'd be worth making all this xxx@xxx.xxx it's so much easier to do with completely new code...

Line:11, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/PcapReaderException.java -> you can put 2014 and your name instead, it's a new file

Line:25, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/PcapReaderException.java -> migh want to re-generate this ID if you copy-pasted it from another file (just delete it and auto-fix the error/warning)

Line:61, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/PcapReaderException.java -> Remove xxx@xxx.xxx it doesn't mean anything for this plugin (which is at 1.0 right?)

Line:24, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> why not store these as long instead? Whatever is easier to handle afterwards. With long you don't have to worry about the length of the array though.

Line:25, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> all final

Line:48, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> ByteBuffer is a tricky API... instead of passing the ByteBuffer here, why not pass the byte[]? (and have the caller extract the array from the bytebuffer).

That, unless you are recursively passing a ByteBuffer through multiple objects. In which case, none of them should call .order(), .position() etc., because then it can mess it up for the other objects.

Line:60, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> How is this constructor different from the previous one? (are both really needed?)

Line:138, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> put parentheses around expressions like these, just to make sure we don't read it as "return fChildPacket":

  return (fChildPacket == null ? string : string + fChildPacket.toString());

Line:143, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> remove this comment. or rather explain why it always returns false

Line:148, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> wow that seems complicated...

what does this bring over getSourceMacAddress() and getDestinationMacAddress() ?

Line:24, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/StreamBuilder.java -> all the above can be final

Line:45, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/StreamBuilder.java -> catch (Exception) is a very, very bad thing to do. Because it also catches runtime exceptions (like NullPointerException, ArrayOutOfBounds, etc.), which is often not expected, and can make debugging a nightmare. As a wise man once said, Do not mess with Exception!

Line:47, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/StreamBuilder.java -> You should either throw an exception here, or initialize fPcapFile to something else, because you are using it below so it should not be null then.

Line:57, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/StreamBuilder.java -> no no no

Line:59, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/StreamBuilder.java -> do something meaningful here too.

And in fact, unless you want to do something then continue the loop, the try {} should be outside of the while(). There is a slight but non-negligible performance impact of doing "try {", so better to do it once rather than every iteration (if of course, it makes sense to).

Line:83, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/StreamBuilder.java -> This returns are write-through collection, so here too it should be a copy (or an ImmutableMap underneath).

Line:12, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/CharacteristicsList.java -> What's the point of this class? ArrayList.equals() will check elements one by one too.

comments below just for the sake of it...

Line:33, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/CharacteristicsList.java -> should use for-each clause instead whenever it's possible:

  for (Object element : array) {

Line:34, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/CharacteristicsList.java -> unsafe cast, there is no guarantee that each Object is a Long

Line:201, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/Packet.java -> Hmm, the way this is implemented makes it a bit weird. Ideally the fChildPacket field should be final, since after the constructors we should now what it is and it should not change.

I tried some funky things of calling this in this class's constructor, but then it doesn't work because the subclass's constructor comes after, and that one sets the things required for findChildPacket() to work...

How about just putting an abstract getChildPacket() method, and storing the fChildPacket field in the subclass?

Line:209, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/Packet.java -> Again, this is a bit weird. What's the use case for this method? (ie, who will call it and what will they do with it?)

Line:15, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/protocol/Protocol.java -> there is nothing to implement in ProtocolField

Line:112, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/protocol/Protocol.java -> { on the same line

Line:50, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/BitBuffer.java -> should be final. Why does this field have a setter??

Line:52, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/BitBuffer.java -> Don't need to keep this, just call fBuffer.order() in the constructor and that's it (why would it need to change over the life time of a BitBuffer? Just create another BitBuffer).

Line:22, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/UDPPacket.java -> final

Line:18, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/TCPPacket.java -> TCPField has no method, just "defines", no need to extend it

Line:38, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/TCPPacket.java -> most/all of these could be final

Line:54, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/TCPPacket.java -> if packet is null, what happens? What will this object be? xxx@xxx.xxx *cough*)

Line:214, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/TCPPacket.java -> perhaps call these method by their "short" names (isCWRFlagSet()), and in the javadoc also give the long name.

Line:21, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> Stream is very generic, and will clash with Java 8's java.util.Stream, which will be used EVERYWHERE! PcapStream, or NetworkStream etc. maybe?

Line:26, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> final

Line:41, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> Since you expose the add/get/remove methods publicly, many threads could end up calling those simultaneously. The easiest way to synchronize these accesses is to use a synchronizedList:

  fList = Collections.synchronizedList(new ArrayList<Packet>());

Line:102, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> you can use '.'

Line:111, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> exposing the Collection directly is dangerous, callers can then call .add() .remove() etc. on it.

Either return a copy, or make it a ImmutableCollection (but still use the Collection return type in that case. We don't want to push the Guava dependency to clients).

Line:118, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> If you make fList a synchronizedList, then iterations must be synchronized manually, like this:

  synchronized (fList) {
    for (Packet packet : fList) {
      ...
    }
  }

This will avoid all possible ConcurrentAccessException's.

Line:14, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/IPacket.java -> you don't use IPacket anywhere, perhaps just the Packet class is enough?

Line:16, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/filter/PacketFilter.java -> both can be final

Always mark fields final if they can be (and they should be, as much as possible).

Line:52, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/filter/PacketFilter.java -> should be "accepts()"

"accept" implies the action, this filter will accept the packet. "accepts" implies "does this filter accept the packet?"

Also, could this method be merged with the previous one? As it is, nothing prevents a user from calling sendToBuilder() without checking the accept() first.

Line:22, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/PcapPacket.java -> all final

Line:14, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> private static final char[] HEX_ARRAY

Line:15, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> add an empty private default constructor:

  private ConversionHelper() {}

Line:23, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> the final on those methods doesn't hurt, but doesn't bring anything (the class can't be extended already).

Line:30, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> IIRC, this will use UTF-16 encoding by default. And that might depend on the platform/JVM... would be safer to specify which encoding to use.

Line:64, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> you can use char, it's slightly faster to append to a String than another String. (and spares you the NON-NLS)

Line:65, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> you are not guaranteed mac[] will have all these elements, would be safer to check for its .length first, and throw an IllegalArgumentException if it doesn't have enough bytes.

Also, no need to declare an object if you return it right away. You can do

  return String.format() + ...

Line:82, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> same comments as the previous method

Line:116, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/ConversionHelper.java -> remove this empty line

-------------------------------------
author: Ivy Mitchell
date: 2014-06-09 13:39:15.000000000

Patch Set 1:

(2 comments)

Line:1, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/CharacteristicsList.java -> copyright header

Line:16, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/BitBuffer.java -> rename misc to util

-------------------------------------
author: Ivy Mitchell
date: 2014-06-09 14:12:16.000000000

Patch Set 1:

(15 comments)

Line:72, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/IPv4Packet.java -> maybe make a boolean getFlag(int value, int bit){
final int mask = 1<<bit;
return ((value & mask) != 0);
}

Line:77, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/IPv4Packet.java -> extract as a constant maybe like LAST_BYTE

Line:18, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/IPv4Field.java -> please explain why it's not 4. A diagram of the packet is useful and fun to make. :)

Line:4, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/TCPField.java -> Could this be merged with IPv4 header, if not, please explain why... [citation]

Line:47, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> ByteOrder prevOrder = header.order();

Line:53, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> header.order(prevOrder);

File Comment: lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> Copyright

Line:1, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/PcapFile.java -> Should this be pcap.core.trace?

Line:4, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/EthernetIIField.java -> Ethernet II is a frame type, it contains 14 bytes of mac (6 dest / 6 src / 2 ether type), 46 - 1550 bytes of data and 4 bytes of crc. These ctes should be in the file. 
I xxx@xxx.xxx
I would also add the unused constants as it is part of the standard.

Line:1, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/BadPcapFileException.java -> copyright

Line:23, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/file/BadPcapFileException.java -> add a BadPcapFileException(Exception e) and an empty ctor one please

Line:41, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/stream/Stream.java -> I would imagine this would be a good place to have an immutable list

Line:4, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/ProtocolField.java -> [citation needed]

Line:6, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/ProtocolField.java -> remove

Line:8, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/filter/PacketFilter.java -> This api seems a little funky... could you walk us through how it's used?

-------------------------------------
author: Itzel Singleton
date: 2014-06-12 22:06:39.000000000

Patch Set 1:

(5 comments)

Line:18, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/IPv4Field.java -> The default header is 20 bytes long. However, in this case, it is specified in 4-bytes block. This choice comes from the IHL field in the IPv4 header. Therefore, the default header length is 20 / 4 = 5. The variable BLOCK_SIZE is used to make the convertion from data block to bytes.

Line:24, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/EthernetIIPacket.java -> I think that storing as a byte array is better in this case.
- MAC and IP addresses are usually in the format xx:xx:xx:xx:xx:xx or 192.168.X.X. Generating the string for showing them in such format is less tricky with a byte array, as no mask is needed.
- I think it uses less RAM (6 bytes for MAC and 4 bytes for IP array, plus a possible overhead since it's an array vs 8 bytes for storing them as long).

But as you said, you have to worry about the array's length...

Line:52, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/misc/BitBuffer.java -> ATM I am not using BitBuffer. I might in the future, so I'll make the corrections when I use this class.

Line:18, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/packet/TCPPacket.java -> But it's an interface? I have to implement it?

Line:15, lttng/org.eclipse.linuxtools.pcap.core/src/org/eclipse/linuxtools/pcap/core/field/ProtocolField.java -> I like it this way. What would an enum bring?

-------------------------------------
