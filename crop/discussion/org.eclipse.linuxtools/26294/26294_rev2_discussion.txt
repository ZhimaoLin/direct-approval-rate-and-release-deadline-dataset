DESCRIPTION

TMF: Validate if an analysis can be executed using the requirements

Change-Id: If4b51af84c4fc3dc7541629b69e950b0cc54cb00
Signed-off-by: Aryana Jones xxx@xxx.xxx


COMMENTS

author: Annalise Jimenez
date: 2014-05-13 20:13:03.000000000

Uploaded patch set 2.

-------------------------------------
author: Brenden Conley
date: 2014-05-13 20:13:10.000000000

Patch Set 2:

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/6991/

-------------------------------------
author: Brenden Conley
date: 2014-05-13 20:51:28.000000000

Patch Set 2: Verified+1

Build Successful 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/6991/ : SUCCESS

-------------------------------------
author: Braxton Mccarthy
date: 2014-05-14 19:11:26.000000000

Patch Set 2: Code-Review-1

(3 comments)

Couple comments, and a question:

So now we have two "levels" of "can a trace run this analysis?". The trace type, defined in the extension point, and now the presence or not of some events in the trace.

Is this still desirable? Could we (not now, but after Luna for instance) make it so the trace type is also checked by an Analysis Requirement, and remove it from the extension point?

For example, the test you added in this patch tests the requirement from the extension point (it's a UST trace, it can't fulfill the reqs of a kernel trace). It would be nice to also have a test for the "does this trace of the right type have the right events" case.

There's also another level we'll want to add : does the event have required fields/contexts, or not. Some analysis, the call stack view for example, requires some specific contexts to be present in the trace. Many things to come :)

Line:189, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/tmf/core/analysis/TmfAbstractAnalysisModule.java -> The annotations are inherited, so you don't HAVE to repeat them. But it doesn't hurt I guess.

Line:272, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/tmf/core/analysis/TmfAnalysisRequirement.java -> should be isFulfilled() (the requirement is fulfilled by  the trace?)

Line:279, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/tmf/core/analysis/TmfAnalysisRequirement.java -> Set.containsAll() would be more clear here?

Never been a big fan of retainsAll(), it's never very obvious what happens, and it modifies the first collection (which means it can't be an immutableCollecction).

-------------------------------------
author: Annalise Jimenez
date: 2014-05-14 20:01:02.000000000

Patch Set 2:

(1 comment)

There has always been 2 levels of "can execute" methods, it's just that the second has returned true until now.

The appliesToTraceType allow to determine if a trace element, which hasn't been instantiated and of which we only know its trace type can run this analysis. That filters the analysis that appear under a trace element in the interface. There is no concept of trace or requirement at this point.

The canExecute method works with an opened trace, thus we have access to the events it may contain. At this point, we can determine if an analysis which we know can run on this trace class, is worth executing if it has the right information (see inline comment for the test).

For the fields/contexts, we could add a builtin requirement type, like "event", that would be "field" and contains the event name and fields/contexts it should contain. Running the isFulfilled method on this requirement would check for the presence of the event and if available fields/contexts. Maybe we would need a TmfCtfAnalysisRequirement for it. We'll see, but the canExecute mechanism would work.

Line:104, lttng/org.eclipse.linuxtools.lttng2.kernel.core.tests/src/org/eclipse/linuxtools/lttng2/kernel/core/tests/analysis/LttngKernelAnalysisTest.java -> The reason why I'm using the UST trace here is because I'm lazy and didn't want to add a new kernel trace and all kernel traces available in tests have the required events, so there is no trace that returns false. But it's wrong. The appliesToTraceType would usually have filtered this trace and it shouldn't get to the canExecute method

-------------------------------------
author: Braxton Mccarthy
date: 2014-05-15 14:40:57.000000000

Patch Set 2:

(1 comment)

You're right, the API was already there, it was just not being used.

Don't we print the available analyses only after the trace has been opened though? So what would be the downside of doing all checking, including trace type, as part of the analysis requirement?

The upside I see would be simplifying to extension point, and centralizing all checking in one place. And we could have funky requirements where we support many different, unrelated trace types (right now it's one class and its subclasses only).

Line:104, lttng/org.eclipse.linuxtools.lttng2.kernel.core.tests/src/org/eclipse/linuxtools/lttng2/kernel/core/tests/analysis/LttngKernelAnalysisTest.java -> It's a good test to have though :)  But yeah, another one would be needed to test a trace that is of the correct type, but doesn't have the required events.

-------------------------------------
author: Annalise Jimenez
date: 2014-05-15 15:24:10.000000000

Patch Set 2:

The API was used, just not implemented :p

And for now, we display the available analyses for a trace type under a closed trace, but add outputs only on instantiated analyses (of opened traces).

It is possible to have more than one tracetype/analyses for funky scenarios. You can also create another extension point with an analysis using the same class but with another name for another trace type, or with different parameters for even funkier scenarios.

But we may rethink all this when we update the UI to show analyses differently, in a more user friendly and intuitive way (with Ludovic we were thinking of dividing the project explorer in 2 viewers and having a bottom viewer list all analyses in different style depending on their status, applicable only to the currently opened trace for instance).

-------------------------------------
