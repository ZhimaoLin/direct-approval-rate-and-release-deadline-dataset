DESCRIPTION

TMF: Introduce the XML state provider for data driven analysis

This patch presents how to define by XML a state provider for a trace. It
contains a test file that works for the test CtfTmfTraces. The patch for XML
analysis module source will be necessary to be able to import XML files and see
the analysis modules appear under the trace.

Change-Id: I4b2db36beb2185049c96344a5faff12d51996317
Signed-off-by: Aryana Jones xxx@xxx.xxx
Signed-off-by: Ayanna Reed xxx@xxx.xxx


COMMENTS

author: Annalise Jimenez
date: 2014-02-03 20:15:44.000000000

Uploaded patch set 9.

-------------------------------------
author: Annalise Jimenez
date: 2014-02-03 20:27:08.000000000

Patch Set 9:

Also ready for review

-------------------------------------
author: Brenden Conley
date: 2014-02-03 20:58:00.000000000

Patch Set 9:

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/5294/

-------------------------------------
author: Annalise Jimenez
date: 2014-02-03 21:25:31.000000000

Patch Set 9:

To test this, you may use the XML file in the xml.core.tests plugin, in test_xml_files/test_valid.xml

That file corresponds to the LTTng kernel state provider. You can import it in TMF by right-clicking the Traces or Experiment folder.

-------------------------------------
author: Brenden Conley
date: 2014-02-03 21:55:34.000000000

Patch Set 9: Verified+1

Build Successful 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/5294/ : SUCCESS

-------------------------------------
author: Ivy Mitchell
date: 2014-02-05 19:48:28.000000000

Patch Set 9: Code-Review+1 IP-Clean+1

nothing looks crazy out of place.

-------------------------------------
author: Ayanna Reed
date: 2014-02-05 19:49:38.000000000

Patch Set 9: Code-Review+1

lgtm

-------------------------------------
author: Annalise Jimenez
date: 2014-02-05 19:58:34.000000000

Patch Set 9:

I'll wait for Alex to review this patch, and the preceding one (the XML definition)

-------------------------------------
author: Braxton Mccarthy
date: 2014-02-18 00:16:11.000000000

Patch Set 9: Code-Review-1

(40 comments)

Oof, that's a big patch! Haven't finished yet, will continue tomorrow. Some comments so far.

Line:53, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> here too, the ATTRIBUTE_TYPE_ prefix is redundant

Line:75, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> any reason this is not public? "default" visibility is bad design in general... This is already in an internal package, so wouldn't be part of the API. public visibility still allows us to use it in tests.

Line:79, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> use switch/case

Line:113, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> shouldn't use C-style names ;)  something like startQuark maybe?

Line:119, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> this should be defined below, only in the case that needs it.

Line:120, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> shouldn't be defined here, it's confusing below when there is a "return quark" that is expected to be -1, we don't necessarily know where it comes from.

You could just define it where needed below, and use "return ss.getQuark..." directly for example. In "error" cases it could use a defined constant "return ROOT_NODE_QUARK" or something.

Line:176, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateAttribute.java -> you can use switch/case here too

Line:52, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> it should be singular (ConditionOperator) because you will use one operator at a time:

 operator = ConditionOperator.OP_NONE

you could even drop the OP_ prefix, since the enum name will always be a prefix

Line:79, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> Java 7 allows switch on strings now! You could use a switch/case here instead of many else-if's. It's a bit more performant (you only do one check).

Line:155, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> using -1 directly in many places can be confusing. This should be in a static final define.

Line:168, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> For simple if blocks, elvis notation can shorten the code a bit (replacing -1 with the constant name of course):

  ITmfStateValue valueState = (quark == -1) ? filter.getEventField(event) : ss.queryOngoingState(quark)

wrap after the ? or : if needed. This has the advantage of being able to declare final variable while doing a test to define them.

Line:172, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> else on the same line

Line:180, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> You can use switch/case on enum's too. This ensures you handle every possible case. "handling" can be just falling-through to the default case.

Line:185, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> why the "test &&" ?  'test' will always be true while you're in this loop no?

Line:194, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlCondition.java -> same here with "test ||"

Line:109, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlEventHandler.java -> jsyk, TimeRangeException is an unchecked exception now. But you can still catch it if you want to log it.

Line:62, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateChange.java -> remove this empty line

Line:77, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateChange.java -> here too public/default constructor

Line:112, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateChange.java -> private interface, hmm, that's... interesting! Looks like a good way to do what you're trying to do here though.

Line:135, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateChange.java -> you could do if ( == null), put the throw in the condition, then avoid having to do an } else {

Line:75, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> those prefixes might be redundant

Line:123, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> you can use switch/case

Line:167, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> here too

Line:223, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> why not xxx@xxx.xxx on the parameter? ;)

Line:249, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> } else on same line

Line:268, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> same line

Line:273, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> could use a switch/case here too, and use this line in the default/others case.

Line:278, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> same line

Line:283, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> same comment here too about use switch/case/default

Line:288, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> same line

Line:324, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> pretty sure this doesn't need wrapping

Line:334, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> add a quick Javadoc description to internal classes

Line:365, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> switch/case (saves one check at most)

also, why is incrementValue() in the method above? Why aren't they all handled in one place, would be clearer? There is a ss.incrementAttribute() now.

Line:413, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> switch/case here too

It's not just for the sake of it ;)  But for example, if we ever add new types of ITmfStateValues (which we've done before), we would then get warnings here asking us to handle them, which is exactly what we want.

Line:416, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> it's potentially unsafe to cast a long straight into an int (it can be bigger than Integer.MAX_VALUE). You have to check it first. you also do this 2 other places below.

Too bad it's not a Long, with that you can do Long.intValue() which clamps it for you.

Line:444, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> switch/case

Line:494, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> The 'ITmfStateSystem' interface would be safer here (since it's for reading only)

Line:515, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> You can use just ITmfStateSystem here too

Line:518, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> switch/case

Line:38, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlLocation.java -> remove this empty line

-------------------------------------
author: Braxton Mccarthy
date: 2014-02-18 19:04:00.000000000

Patch Set 9:

(2 comments)

Rest of the comments.

As mentioned in the last comment, I find that in many places ArrayList is used for no particular reason. That implementation has the added cost of having to resize the "capacity" array as you insert elements, and we don't always make use of its benefits.

* If the order of elements is important, AND you access them with a specific index, use ArrayList
* If the order of elements is important, but you only iterate over the whole list, use LinkedList.
* If the order of elements is *not* important, you only want to go over every element, use Set.

Line:207, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/tmf/analysis/xml/core/stateprovider/XmlStateProvider.java -> Nothing throws a checked exception in here?

Is this a case where you want to protect against badly-formed XML files that might crash the program? In this case, it should only catch the types that can actually happen (or even better, do 'if' checks before dereferencing references or accessing arrays, if NPE or AOOBE are the problem).

And e.printStackTrace() is not a good way to handle it. Either log it, or pop a message to the user.

Line:218, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/tmf/analysis/xml/core/stateprovider/XmlStateProvider.java -> Don't expose the whole list. Either a single getter getLocation(int), or an Iterable, or both if needed.

And even when using Iterable, you also have to be careful for concurrent accesses. But in this case, elements are added to the array in loadXml(), which is called by the constructor. Which means that once this method becomes accessible (after the constructor has run), it should not be modifier afterwards.

In fact, you know what would be clean? Putting the loadXml() stuff right in the constructor, and saving the fields themselves as unmodifiableList/Map's. Then you can expose an Iterable view, but don't have to worry about locking anywhere.

Also, you often use List, when in fact the only operation to do is to iterate on them. If the order is not important you should use Set/HashSet (or TreeSet if you store Integers/Longs), it would be more performant.

-------------------------------------
author: Annalise Jimenez
date: 2014-02-19 16:40:46.000000000

Patch Set 9:

(2 comments)

extra comments, I'm working on the corrections.

Line:112, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateChange.java -> It avoids a few if then else in a few places so yeah! works well!

Line:365, lttng/org.eclipse.linuxtools.tmf.analysis.xml.core/src/org/eclipse/linuxtools/internal/tmf/analysis/xml/core/stateprovider/model/TmfXmlStateValue.java -> What do you mean with the incrementValue()? The value of the increment depends on the class of the StateValue (the increment is not necessarily 1), so classes may override this method.

-------------------------------------
