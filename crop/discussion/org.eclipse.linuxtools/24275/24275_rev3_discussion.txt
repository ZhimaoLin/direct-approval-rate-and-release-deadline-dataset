DESCRIPTION

tmf: Fold AlphaNumAttritbute class into the main one

Initially it was planned to allow for different types of attributes,
which could have children whose name could only be numbers, or
sequences of alphanumerical characters.

In the end, it was too complicated to expose this functionality in
StateSystem's API, so to remain as generic as possible, all attributes
are of type "alphanumerical".

The separate class is now unneeded. This also simplifies synchronizing
the container of sub-attributes (which should fix bug #431706).

Change-Id: I626bd07de660131ef6432cb10b0e783201c24782
Signed-off-by: Braxton Mccarthy xxx@xxx.xxx


COMMENTS

author: Braxton Mccarthy
date: 2014-04-04 18:50:21.000000000

Uploaded patch set 3.

-------------------------------------
author: Braxton Mccarthy
date: 2014-04-04 18:51:17.000000000

Patch Set 3:

Bigger refactor, which merges the two separate Attribute classes into one. This makes it much easier to do the synchronization.

-------------------------------------
author: Luciana Barry
date: 2014-04-04 19:27:51.000000000

Patch Set 3:

(2 comments)

Line:55, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/internal/tmf/core/statesystem/Attribute.java -> Not sure if it matters but if it's not a LinkedHashMap then getSubAttributes will return the list of sub attributes in some random order.

Line:87, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/internal/tmf/core/statesystem/Attribute.java -> Wouldn't ArrayList be much more efficient here?

-------------------------------------
author: Braxton Mccarthy
date: 2014-04-04 20:02:45.000000000

Patch Set 3:

(2 comments)

Line:55, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/internal/tmf/core/statesystem/Attribute.java -> Good point, I did think about it. But we only access the children with their name now, so the order is not important.

Line:87, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/internal/tmf/core/statesystem/Attribute.java -> We only iterate on the results (afaics, unless I'm mistaken?), .get(i) wouldn't mean anything: it's not the quark or anything, it's just the order in which the children for this guy were created.

We do know the size of the array when we create it, since we create it from an existing collection, so it shouldn't be much slower to create an ArrayList though. I think it'd end up being the same in the end.

-------------------------------------
author: Brenden Conley
date: 2014-04-04 20:29:30.000000000

Patch Set 3: Verified+1

Build Successful 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/6248/ : SUCCESS

-------------------------------------
author: Luciana Barry
date: 2014-04-04 20:59:17.000000000

Patch Set 3:

(1 comment)

Line:87, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/internal/tmf/core/statesystem/Attribute.java -> I wasn't referring to the access efficiency, but to the creation efficiency.
Both ArrayList and LinkedList constructors call the collection's toArray(), then ArrayList stores the array directly, whereas LinkedList needs to create a list with Node pointers out of the array. So ArrayList would definitely be faster.

Not to mention that LinkedList is infinitely more annoying to debug than ArrayList...

-------------------------------------
author: Ivy Mitchell
date: 2014-04-04 21:15:09.000000000

Patch Set 3: Code-Review+1 IP-Clean+1

lgtm

-------------------------------------
author: Braxton Mccarthy
date: 2014-04-04 22:03:37.000000000

Patch Set 3:

(1 comment)

Line:87, lttng/org.eclipse.linuxtools.tmf.core/src/org/eclipse/linuxtools/internal/tmf/core/statesystem/Attribute.java -> If the items in the initial collection are contiguous in memory (as in, already in an ArrayList for exemple), then .toArray() and Arrays.copy() will be very fast, yes. However here they come from the values in a Map, very low chance of them being contiguous. So you end up reading the values one by one in both cases. So I doubt there would be much difference in creation time here.

(actually benchmarking it is left as an exercise to the reader >.>)

I chose LinkedList to reflect the expected access pattern, but still, since there should not be much difference, I wouldn't mind using ArrayList either. Do you still have shares in ArrayList? ;)

-------------------------------------
