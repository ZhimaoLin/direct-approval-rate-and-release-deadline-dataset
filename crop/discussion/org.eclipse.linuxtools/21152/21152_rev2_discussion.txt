DESCRIPTION

tmf: Rework analysis-returning methods in ITmfTrace

Make the analysis accesses thread-safe: each access is now encased
in a synchronized block (or using the synchronizedMap wrapper).

This also implies exposing only Iterable's in the interface, which
is a good practice in general. If a caller could get a reference to
the map (even through unmodifiableMap), we'd have no guarantee that
they'd correctly lock their iterations, which could result in a
concurrent access error if the map is modified internally at the
same time.

Change-Id: Ibd2f1130ab9839ad20c3df3ac7c92119754ecc42
Signed-off-by: Braxton Mccarthy xxx@xxx.xxx


COMMENTS

author: Braxton Mccarthy
date: 2014-01-28 22:01:31.000000000

Uploaded patch set 2.

-------------------------------------
author: Braxton Mccarthy
date: 2014-01-28 22:03:31.000000000

Patch Set 2:

Rebased on fixed master so it can build. Will still have to be rebased on the live-updating patch once that one is in.

So the debate was now at:  if the fAnalysisModules is a map of <String, IAnalysisModule>, how can a "T" not be a IAnalysisModule too?

-------------------------------------
author: Brenden Conley
date: 2014-01-29 00:30:15.000000000

Patch Set 2:

Build Started https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/5239/

-------------------------------------
author: Brenden Conley
date: 2014-01-29 01:22:44.000000000

Patch Set 2: Verified+1

Build Successful 

https://hudson.eclipse.org/linuxtools/job/linuxtools-gerrit/5239/ : SUCCESS

-------------------------------------
author: Annalise Jimenez
date: 2014-01-29 14:23:59.000000000

Patch Set 2:

> if the fAnalysisModules is a map of <String, IAnalysisModule>, how can a "T" not be a IAnalysisModule too?

How? Well, it IS an analysis module, but the module object can implement something else too. And this method was originally a way to get about anything an analysis module can be, whether an analysis module descendant or something else entirely.

The debate question I'm asking: Why limit the returned class to IAnalysisModule when it is absolutely not necessary? (the only place where it is sort of required now, the TmfStateSystemExplorer, is commented with a big FIXME)

-------------------------------------
author: Braxton Mccarthy
date: 2014-01-29 19:10:06.000000000

Patch Set 2:

Hmm, right, the T here means more "I want my return values casted to this class", so yes it will also implement IAnalysisModule, but the caller might to want to get it casted to something else. Fair enough.

The getAnalysisModules(Class<T> class) method could keep "T". In fact we can just change the API and nothing else changes.

For the other added method though, getAnalysisModule(Class<T> class, String id), that one will have to keep "T extends IAnalysisModule", because "id" only makes sense if T is an analysis module.

How does that sound?

-------------------------------------
author: Annalise Jimenez
date: 2014-01-29 19:51:11.000000000

Patch Set 2:

Ok fair enough. Let's have getAnalysisModules(Class<T> class) return generic T and the other extends IAnalysisModule.

-------------------------------------
